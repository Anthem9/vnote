# 文件和文件对象
内置函数``open(name [,mode [,bufsize]])``用于打开和创建文件对象，如下所示：
```python
f = open("foo")          # 打开“foo”以供读取
f = open("foo", 'r')     # 打开“foo”以供读取（同上）
f = open("foo", 'w')     # 打开对象以进行写入
```

* 文件模式``'r'``表示读取，``'w'``表示写入，``'a'``表示附加。
* 如果正在处理二进制数据，可以将``'b'``附加到文件模式后面，如``'rb'``或``'wb'``。
* 这将禁用换行符转换，如果关注处理二进制数据的代码的可移植性，则应该包含``'b'``。
## 文件方法
|方法|描述|
|--|--|
|``f.read([n])``|最多读取``n``个字节|
|``f.readline([n])``|读取单行输入的最多``n``个字符。如果省略了``n``,该方法将读取整行|
|``f.readlines([size])``|读取所有行并返回一个列表。``size``是可选的，用于指定在读取操作停止前在文件上读取的近似字符数|
|``f.write(s)``|写入字符串``s``|
|``f.writelines(lines)``|写入序列``lines``中的所有字符串|
|``f.close()``|关闭文件|
|``f.tell()``|返回当前文件指针|
|``f.seek(offset [, whence])``|查找新文件位置|
|``f.isatty()``|如果``f``是一个交互式终端，则返回``1``|
|``f.flush()``|清除输出缓冲区|
|``f.truncate([size])``|将文件截断为最多``size``字节
|``f.fileno()``|返回一个整数文件描述符，如果关闭就发出``valueError``异常|
|``f.next()``|返回下一行或引发``StopIteration``。在Python中，对应的方法称为``f.__next__()``|
* read()和readline()返回一个空字符串来表示文件结束（EOF）。
* 以下代码展示了如何检测EOF条件：
```python
while True:
    line = f.readline()
    if not line:    #EOF
        break
```
* 读取文件中所有行的一种便捷方式是用``for``循环进行迭代。例如：
```python
for line in f: #迭代文件中所有行
    #对某一行执行特定操作
    ...
```
* ``write()``和``writelines()``不会将换行字符添加到输出中，所以生成的所有输出都应该已经包含所有必要的格式。
* 在内部，每个文件对象都有一个文件指针，用于存储下次读取或写入操作所需的字节偏移位置。
* ``tell()``方法以长整形返回文件指针的当前值。
* ``seek()``方法根据给定的``offset``和``whence``中的位置规则随机访问文件的各个部分。
* 如果``whence``为``0``（默认值），``seek()``假设``offset``为相对于文件的开头的偏移量；
* 如果``whence``为``1``，将参照当前位置偏移；
* 如果``whence``为``2``，将相对于文件末尾进行偏移。
* ``seek()``以整数形式返回文件指针的新值。
* 应该注意，文件指针与``open()``返回的文件对象相关联，而不是与文件本身相关联。
* 可以在同一个程序中（或在不同程序中）多次打开同一个文件。
* 每个打开文件的实例都拥有自己的文件指针，可以独立操作该指针。

